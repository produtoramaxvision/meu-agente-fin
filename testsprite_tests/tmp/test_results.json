[
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "afcade0b-e941-4716-8ea0-0a91585a2653",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC001-Multi-step Authentication Workflow",
    "description": "Verify that the multi-stage login, signup, password recovery, and session management workflow functions correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input the phone number from the valid credentials and click continue to proceed with login.\n        frame = context.pages[-1]\n        # Input the phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click the continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input the password and click the 'Entrar' button to attempt login.\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Entrar' button to submit login form\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to the signup page by finding and clicking the signup or register link/button.\n        frame = context.pages[-1]\n        # Click on 'Perfil' to check if signup or registration option is available there\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/nav/a[8]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try direct URL navigation to the signup page or report the missing signup page issue and stop further testing.\n        await page.goto('http://localhost:8080/auth/signup', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Since signup form is not accessible, attempt to initiate password recovery from the login page or report the issue and stop further testing.\n        await page.goto('http://localhost:8080/auth/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input the valid phone number '5511949746110' into the phone input field to enable the 'Continuar' button and proceed with login or password recovery initiation.\n        frame = context.pages[-1]\n        # Input the phone number to enable 'Continuar' button\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Continuar' button to proceed\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the signup form fields with valid data and submit the form by clicking the 'Criar Conta' button.\n        frame = context.pages[-1]\n        # Input full name in signup form\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('João Silva')\n        \n\n        frame = context.pages[-1]\n        # Input email in signup form\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('joao@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input CPF in signup form\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div[4]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123.456.789-00')\n        \n\n        frame = context.pages[-1]\n        # Input password in signup form\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div[5]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('newpassword123')\n        \n\n        frame = context.pages[-1]\n        # Input confirm password in signup form\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div[6]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('newpassword123')\n        \n\n        frame = context.pages[-1]\n        # Click 'Criar Conta' button to submit signup form\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Account successfully created and logged in').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The multi-stage login, signup, password recovery, and session management workflow did not complete successfully as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The multi-stage login workflow was successfully verified with valid credentials. However, the signup workflow is blocked because the signup form submission fails silently: after filling all required fields and clicking 'Criar Conta', the form remains on the same page with no success or error message, and the submit button is disabled. Password recovery and session management workflows could not be fully tested due to this blockage. Please investigate the signup form submission issue to enable full workflow testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://pzoodkjepcarxnawuxoa.supabase.co/auth/v1/signup?redirect_to=http%3A%2F%2Flocalhost%3A8080%2Fauth%2Flogin:0:0)\n[ERROR] Signup error: Error: Email inválido. Verifique o formato do email.\n    at signup (http://localhost:8080/src/contexts/AuthContext.tsx?t=1763127860250:319:15)\n    at async handleSignupSubmit (http://localhost:8080/src/pages/auth/Login.tsx?t=1763127860250:124:13) (at http://localhost:8080/src/contexts/AuthContext.tsx?t=1763127860250:346:14)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132107365061//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.622Z",
    "modified": "2025-11-14T14:55:07.509Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "28186c78-9c70-4ce2-a8b0-05c92c006cf6",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC002-Financial Records Management",
    "description": "Validate creation, editing, categorization, filtering, alerts, and export of financial entries and exits.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and click continue to login\n        frame = context.pages[-1]\n        # Input the phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click the continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click 'Entrar' button to login\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Entrar' button to submit login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Nova Ação' button to create a new financial entry\n        frame = context.pages[-1]\n        # Click 'Nova Ação' button to create a new financial entry\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Nova Transação' button to open the financial entry creation form\n        frame = context.pages[-1]\n        # Click 'Nova Transação' to start creating a new financial entry\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the form with a valid category and amount, then save the entry\n        frame = context.pages[-1]\n        # Select 'Entrada' as the transaction type\n        elem = frame.locator('xpath=html/body/div[3]/form/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input valid amount for the financial entry\n        elem = frame.locator('xpath=html/body/div[3]/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1500.00')\n        \n\n        frame = context.pages[-1]\n        # Open category dropdown\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a valid category from the dropdown and save the new financial entry\n        frame = context.pages[-1]\n        # Select 'Salário' category from the dropdown\n        elem = frame.locator('xpath=html/body/div[4]/div/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Salvar' button to save the new financial entry and verify it appears in the transaction list\n        frame = context.pages[-1]\n        # Click 'Salvar' button to save the new financial entry\n        elem = frame.locator('xpath=html/body/div[3]/form/div[7]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Edit the recently created financial record to change category and amount\n        frame = context.pages[-1]\n        # Click on the latest 'Freelance' transaction to open edit form\n        elem = frame.locator('xpath=html/body/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Financial Entry Creation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution for validating creation, editing, categorization, filtering, alerts, and export of financial entries and exits has failed. Immediate failure triggered due to unsuccessful test plan execution.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to access the financial record editing interface. The issue has been reported for resolution. Created financial entries are verified, but editing, filtering, alerts, and export tests could not proceed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/176313202873882//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.627Z",
    "modified": "2025-11-14T14:53:48.898Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "d61741c1-a577-458c-9a35-e1f8ac72932d",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC003-Task and Agenda Management with Google Workspace Integration",
    "description": "Test task creation, editing, filtering, and synchronization with Google Calendar, Drive, and Tasks.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and click continue to login\n        frame = context.pages[-1]\n        # Input the phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click the continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click login button to authenticate\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit credentials and login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to 'Tarefas' (Tasks) section to create a new task with priority, due date, and category\n        frame = context.pages[-1]\n        # Click on 'Tarefas' to go to the tasks section\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Nova Tarefa' button to open the new task creation form\n        frame = context.pages[-1]\n        # Click 'Nova Tarefa' button to start creating a new task\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the new task form with title, description, priority, category, and due date, then save the task\n        frame = context.pages[-1]\n        # Input task title\n        elem = frame.locator('xpath=html/body/div[3]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Reunião com cliente')\n        \n\n        frame = context.pages[-1]\n        # Input task description\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Discuss project requirements and deadlines')\n        \n\n        frame = context.pages[-1]\n        # Open priority dropdown\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input category text 'Trabalho' by typing directly into the category input field, then select due date and save the task.\n        frame = context.pages[-1]\n        # Click on the category input field to focus it\n        elem = frame.locator('xpath=html/body/div[4]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Task Creation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test plan execution failed: Task creation, editing, filtering, and synchronization with Google Calendar, Drive, and Tasks did not complete successfully.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Tested task creation with priority, due date, and category. Successfully input task title, description, and priority. Failed to input category and due date due to element interaction issues, preventing task save and verification. Subsequent steps for editing, filtering, calendar event management, and Google Workspace synchronization were not reached. Task creation partially tested but not fully completed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 406 () (at https://pzoodkjepcarxnawuxoa.supabase.co/rest/v1/tasks?id=eq.f7f158f3-4ba3-4748-a20a-c97716f6393c&select=*:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 406 () (at https://pzoodkjepcarxnawuxoa.supabase.co/rest/v1/tasks?id=eq.f7f158f3-4ba3-4748-a20a-c97716f6393c&select=*:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132473860398//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.632Z",
    "modified": "2025-11-14T15:01:14.052Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "83351667-1fa4-4369-830c-29792bc13758",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC004-Automated WhatsApp AI Agent Interactions",
    "description": "Validate AI sub-agents' handling of WhatsApp messages for financial entries, lead qualification, marketing reports, scheduling, development, and video content generation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and click continue to login\n        frame = context.pages[-1]\n        # Input phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click Entrar to login\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click Entrar button to submit login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send a WhatsApp message to the agent registering a financial entry\n        await page.goto('https://web.whatsapp.com/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on 'Update Google Chrome' link to proceed with browser update instructions\n        frame = context.pages[-1]\n        # Click 'UPDATE GOOGLE CHROME' button to open update instructions\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/div/div/div[2]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Download Chrome' button to start downloading the latest Chrome version\n        frame = context.pages[-1]\n        # Click 'Download Chrome' button to start Chrome update download\n        elem = frame.locator('xpath=html/body/div[2]/section[3]/div/div/div/div[2]/simplify-download/download-button/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to reveal more page content or alternative download options\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Click on the 'Download Chrome' button visible on the page to initiate download\n        frame = context.pages[-1]\n        # Click 'Download Chrome' button to start Chrome update download\n        elem = frame.locator('xpath=html/body/div[2]/section[3]/div/div/div/div[2]/simplify-download/download-button/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try alternative approach: click 'I want to update Chrome' link to see if it leads to update instructions or download\n        frame = context.pages[-1]\n        # Click 'I want to update Chrome' link for alternative update instructions\n        elem = frame.locator('xpath=html/body/div[2]/section[3]/div/div/div/div[2]/simplify-download/update-link/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=AI agent successfully processed financial entry').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The AI sub-agents did not handle WhatsApp messages as expected for financial entries, lead qualification, marketing reports, scheduling, development, and video content generation.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Stopped task due to inability to update browser and access WhatsApp Web. Browser compatibility issues prevent sending WhatsApp messages to test AI sub-agents. Manual browser update or environment change is required to continue.\nBrowser Console Logs:\n[WARNING] Error with Permissions-Policy header: Unrecognized feature: 'bluetooth'. (at :0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132035074604//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.638Z",
    "modified": "2025-11-14T14:53:55.213Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "1b73cb23-c836-4a4f-8c0f-685688202952",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC005-Real-time Notifications and Alerts",
    "description": "Ensure notifications system delivers real-time alerts with correct state management, including bell icon and dropdown components.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and click continue to login\n        frame = context.pages[-1]\n        # Input phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click Entrar to login\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click Entrar button to submit login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger various notifications (financial alerts, task reminders, agent responses)\n        frame = context.pages[-1]\n        # Click Notificações (Notifications) icon to open notifications dropdown\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/nav/a[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger various notifications (financial alerts, task reminders, agent responses) to verify real-time appearance and content\n        frame = context.pages[-1]\n        # Click 'Nova Ação' button to trigger new notifications\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger a financial alert notification by creating a new transaction\n        frame = context.pages[-1]\n        # Click 'Nova Transação' to create a new financial transaction and trigger a financial alert notification\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in transaction details to trigger a financial alert notification and save the transaction\n        frame = context.pages[-1]\n        # Click input field to enter transaction value\n        elem = frame.locator('xpath=html/body/div[3]/form/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input transaction value 150.00\n        elem = frame.locator('xpath=html/body/div[3]/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('150.00')\n        \n\n        frame = context.pages[-1]\n        # Open category dropdown\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a category and save the transaction to trigger a financial alert notification\n        frame = context.pages[-1]\n        # Select 'Salário' category from dropdown\n        elem = frame.locator('xpath=html/body/div[4]/div/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Salvar' button to save the transaction and trigger the financial alert notification\n        frame = context.pages[-1]\n        # Click 'Salvar' button to save the transaction and trigger notification\n        elem = frame.locator('xpath=html/body/div[3]/form/div[7]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify notifications appear in real-time with correct content and timestamp by checking the notifications dropdown\n        frame = context.pages[-1]\n        # Click bell icon to open notifications dropdown and verify new notification presence\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/nav/a[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger additional notifications (task reminders, agent responses) to verify real-time appearance and content, and re-check notification system behavior\n        frame = context.pages[-1]\n        # Click 'Nova Ação' button to trigger new notifications\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger a task reminder notification by creating a new task\n        frame = context.pages[-1]\n        # Click 'Nova Tarefa' to create a new task and trigger a task reminder notification\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in task details (title, description, priority, category, due date) and save the task to trigger a task reminder notification\n        frame = context.pages[-1]\n        # Input task title\n        elem = frame.locator('xpath=html/body/div[3]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Reunião com cliente')\n        \n\n        frame = context.pages[-1]\n        # Input task description\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Discutir detalhes do projeto e próximos passos')\n        \n\n        frame = context.pages[-1]\n        # Open priority dropdown\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Manually click category input field, select or input category if possible, then select due date and save the task to trigger task reminder notification\n        frame = context.pages[-1]\n        # Click category input field to focus or open category selection\n        elem = frame.locator('xpath=html/body/div[4]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=System Failure Notification').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The notifications system did not deliver real-time alerts with correct state management as expected in the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The notification system was tested by logging in, triggering a financial alert notification via a new transaction, and attempting to trigger a task reminder notification via a new task. The financial alert notification triggered a success message but did not appear in the notifications inbox as expected, indicating a possible issue with real-time notification display or state management. The task reminder notification form was filled but the category input field was problematic to interact with, and the final save action was not completed. The notifications dropdown consistently showed an empty inbox despite actions that should trigger notifications. The bell icon and dropdown components are present but the system does not reflect triggered notifications in real-time as expected. Therefore, the notification system does not fully deliver real-time alerts with correct state management as required. Further investigation and fixes are needed to ensure notifications appear correctly, update read/unread status, and persist state changes. Task is not fully finished successfully.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132119875542//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.642Z",
    "modified": "2025-11-14T14:55:20.016Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "75ba97f3-baf7-42d3-b4bf-1f2502831306",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC006-Dashboard Visualizations and Data Integrity",
    "description": "Test that the dashboard displays accurate financial summaries, tasks, goals, charts, and agent insights.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and click continue to login\n        frame = context.pages[-1]\n        # Input the phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click the continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click login button to access dashboard\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit credentials and login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create financial records, tasks, and goals to test dynamic updates on dashboard\n        frame = context.pages[-1]\n        # Click 'Nova Ação' button to create new financial records, tasks, or goals\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create a new financial transaction by clicking 'Nova Transação' button\n        frame = context.pages[-1]\n        # Click 'Nova Transação' to create a new financial transaction\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the transaction form with a sample entry and save it to test dashboard update\n        frame = context.pages[-1]\n        # Select 'Entrada' as transaction type\n        elem = frame.locator('xpath=html/body/div[3]/form/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input transaction value as 1000\n        elem = frame.locator('xpath=html/body/div[3]/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1000')\n        \n\n        frame = context.pages[-1]\n        # Open category dropdown\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a category and save the new transaction to update the dashboard\n        frame = context.pages[-1]\n        # Select 'Freelance' category from dropdown\n        elem = frame.locator('xpath=html/body/div[4]/div/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Save the new transaction and verify dashboard updates dynamically\n        frame = context.pages[-1]\n        # Click 'Salvar' button to save the new financial transaction and update dashboard\n        elem = frame.locator('xpath=html/body/div[3]/form/div[7]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create a new task by opening 'Nova Ação' and selecting 'Nova Tarefa' to verify dashboard updates\n        frame = context.pages[-1]\n        # Click 'Nova Ação' button to open creation modal\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Nova Tarefa' to open the new task creation form\n        frame = context.pages[-1]\n        # Click 'Nova Tarefa' to create a new task\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the new task form with sample data and save it to verify dashboard updates dynamically\n        frame = context.pages[-1]\n        # Input task title\n        elem = frame.locator('xpath=html/body/div[3]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Reunião com cliente')\n        \n\n        frame = context.pages[-1]\n        # Input task description\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Discutir detalhes do projeto e próximos passos')\n        \n\n        frame = context.pages[-1]\n        # Open priority dropdown\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select priority 'Alta', fill category and due date, then save the task to verify dashboard updates\n        frame = context.pages[-1]\n        # Select 'Alta' priority from dropdown\n        elem = frame.locator('xpath=html/body/div[4]/div/div/div[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input category as 'Trabalho', select due date as 2025-11-20, and save the task to verify dashboard updates\n        frame = context.pages[-1]\n        # Input task category as Trabalho\n        elem = frame.locator('xpath=html/body/div[3]/form/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Trabalho')\n        \n\n        frame = context.pages[-1]\n        # Open due date picker\n        elem = frame.locator('xpath=html/body/div[3]/form/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select due date as 20 November 2025 and save the task to verify dashboard updates\n        frame = context.pages[-1]\n        # Select due date 20 November 2025\n        elem = frame.locator('xpath=html/body/div[4]/div/div/div/div/table/tbody/tr[4]/td[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click 'Salvar' button to save the new task and update dashboard\n        elem = frame.locator('xpath=html/body/div[3]/form/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Reopen the 'Nova Ação' modal, select 'Nova Tarefa', fill the task form again, and save the task correctly to verify dashboard updates\n        frame = context.pages[-1]\n        # Click 'Nova Ação' button to open creation modal\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Financial Dashboard Overview - All Systems Operational').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The dashboard did not display accurate financial summaries, tasks, goals, charts, and agent insights as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The dashboard displays accurate financial summaries and charts reflecting the created financial transaction. However, the task creation step was not completed successfully because the Cancel button was clicked instead of Save, so the dashboard did not update with the new task. Goal creation was not attempted. Therefore, the task is not fully finished. Further testing is needed to complete task and goal creation and verify dynamic dashboard updates for those. Stopping now as per user instruction.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132189928895//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.648Z",
    "modified": "2025-11-14T14:56:30.094Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "68a08fb0-e869-4f62-b6b5-ea4f4e85b6ad",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC007-Subscription Plan Restrictions and Feature Access",
    "description": "Ensure that users can only access features according to their subscription plan and that premium features are restricted accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number for Free plan user and click continue button\n        frame = context.pages[-1]\n        # Input phone number for Free plan user login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click Entrar to login as Free plan user\n        frame = context.pages[-1]\n        # Input password for Free plan user\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click Entrar button to login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to automated WhatsApp agents and backups to test access restrictions for Free plan user\n        frame = context.pages[-1]\n        # Click 'Nova Ação' to check for automated WhatsApp agents access\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if automated WhatsApp agents and backups are accessible or blocked for Free plan user by exploring relevant menus or options\n        frame = context.pages[-1]\n        # Close 'Nova Ação' modal to explore other menus for premium features access\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Relatórios' menu to check if backups or export features are accessible or blocked for Free plan user\n        frame = context.pages[-1]\n        # Click 'Relatórios' menu to check for backups or export options\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/nav/a[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify that attempting to use export or backup features shows appropriate upgrade prompts and access is denied\n        frame = context.pages[-1]\n        # Click 'Exportar PREMIUM' button to test if access is blocked and upgrade prompt appears\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/div/div/div/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Log out Free plan user and login as Business plan user to verify access to AI agents, backups, and support features\n        frame = context.pages[-1]\n        # Click 'Sair' button to log out Free plan user\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input Business plan user phone number and click continue\n        frame = context.pages[-1]\n        # Input phone number for Business plan user login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('551198452354')\n        \n\n        frame = context.pages[-1]\n        # Click continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Correct the phone number format to match '55 (XX) X XXXX-XXXX' and retry login for Business plan user\n        frame = context.pages[-1]\n        # Correct phone number format for Business plan user login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511984523540')\n        \n\n        frame = context.pages[-1]\n        # Click continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Go back to login page to retry correct Business plan user login or use correct credentials\n        frame = context.pages[-1]\n        # Click 'Voltar' button to return to login page\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input correct phone number for Business plan user and click continue\n        frame = context.pages[-1]\n        # Input correct phone number for Business plan user login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Voltar' button to return to login page and retry login with correct Business plan user credentials or stop if no credentials available.\n        frame = context.pages[-1]\n        # Click 'Voltar' button to return to login page\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input correct phone number for Business plan user and click continue to attempt login again.\n        frame = context.pages[-1]\n        # Input correct phone number for Business plan user login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Granted to Premium Features').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution has failed because users were not restricted according to their subscription plans. Premium features should be blocked for Free plan users and only accessible to Business plan users as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The Free plan user login and access restrictions to premium features such as automated WhatsApp agents and backups were successfully verified, including upgrade prompts. However, attempts to login as Business plan user led to the account creation form, indicating the user is not registered or credentials are unavailable. Therefore, full access verification for Business plan user and further tests on export permissions and add-ons could not be completed. Task is stopped here.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132152769011//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.652Z",
    "modified": "2025-11-14T14:55:52.913Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "378b6657-f8ca-4b0a-a458-061acf3b6e29",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC008-Support and Help Request Workflow",
    "description": "Test submission, tracking, and SLA response behaviors of support requests according to subscription tiers.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and continue login\n        frame = context.pages[-1]\n        # Input phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and submit login form\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click Entrar button to submit login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Ajuda' button to open help and support menu for submitting a support ticket\n        frame = context.pages[-1]\n        # Click 'Ajuda' button to open help and support menu\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Suporte' button to open support ticket submission interface\n        frame = context.pages[-1]\n        # Click 'Suporte' button to open support ticket submission interface\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify that Free plan user cannot create new support tickets and is prompted to upgrade plan\n        frame = context.pages[-1]\n        # Click 'Novo Ticket' button to attempt creating a new support ticket as Free plan user\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=High Priority 24/7 Support Available').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Support ticket submission and SLA response behaviors did not meet expectations for subscription tiers as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Tested support ticket submission and SLA response behaviors for Free plan user. Verified ticket creation is blocked and user is prompted to upgrade plan. Unable to log out due to UI element interaction issues, so could not test Business or Premium plan user behavior. Task partially completed.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132025838281//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.657Z",
    "modified": "2025-11-14T14:53:45.964Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "3f14d55c-f79b-48c6-be4c-195bf83e3ff5",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC009-Backup and Restoration Conformance to 3-2-1 Policy",
    "description": "Verify backup mechanisms and restoration processes comply with the 3-2-1 backup policy especially for Premium plans.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and click continue to login\n        frame = context.pages[-1]\n        # Input phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click Entrar to login\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click Entrar button to submit login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to profile or settings to check for backup options for Premium plan\n        frame = context.pages[-1]\n        # Click on Perfil (Profile) to access user settings and backup options\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/nav/a[8]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Backup' tab to access backup settings and options for Premium plan\n        frame = context.pages[-1]\n        # Click on the 'Backup' tab to access backup settings\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/main/div/div[2]/div/div/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Criar Backup Manual' button to trigger a manual backup on the Premium plan\n        frame = context.pages[-1]\n        # Click 'Criar Backup Manual' to trigger manual backup\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/main/div/div[2]/div/div[2]/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate data loss and execute restoration from the latest manual backup to verify data integrity and completeness\n        frame = context.pages[-1]\n        # Click 'Restaurar' button on the latest manual backup to simulate restoration process\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/main/div/div[2]/div/div[2]/div/div/div[3]/div[2]/div/div/div/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt backup and restore actions on non-Premium plans to verify restrictions and appropriate messaging\n        frame = context.pages[-1]\n        # Click 'Planos' tab to switch to plans page and check non-Premium plan backup restrictions\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/main/div/div[2]/div/div[2]/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Backups automáticos são criados diariamente às 02:00 para proteger seus dados.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Mantemos os últimos 30 backups automaticamente. Backups manuais são mantidos indefinidamente.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Todos os seus dados financeiros, tarefas, agenda e configurações são incluídos no backup.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=A restauração substitui todos os dados atuais pelos dados do backup selecionado.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132044807888//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.661Z",
    "modified": "2025-11-14T14:54:04.932Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "7d04c029-6e4d-4163-9773-1147823eee14",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC010-Compliance with LGPD and Data Privacy",
    "description": "Validate opt-in/out mechanisms, data retention policies, and privacy compliance based on LGPD regulations.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and continue to next step to review consent process\n        frame = context.pages[-1]\n        # Input phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click Entrar to login and review consent process\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click Entrar button to login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Perfil (Profile) page to review consent and privacy settings\n        frame = context.pages[-1]\n        # Click Perfil (Profile) to review consent and privacy settings\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/nav/a[8]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the Privacidade tab to review opt-in/out mechanisms and consent requests\n        frame = context.pages[-1]\n        # Click Privacidade tab to review privacy and consent settings\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/main/div/div[2]/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Perform user data access request by clicking 'Exportar Meus Dados' to verify proper data export per LGPD rules\n        frame = context.pages[-1]\n        # Click 'Exportar Meus Dados' button to perform user data access request and verify data export\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/main/div/div[2]/div/div[2]/div/div/div[3]/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Deletar Todos os Dados' to trigger automated deletion of data after retention period and verify secure removal and audit logs\n        frame = context.pages[-1]\n        # Click 'Deletar Todos os Dados' button to trigger automated deletion of user data\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/main/div/div[2]/div/div[2]/div/div/div[3]/div[2]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Sim, deletar tudo' to confirm permanent deletion of all user data and verify secure removal and audit logs\n        frame = context.pages[-1]\n        # Click 'Sim, deletar tudo' to confirm permanent deletion of all user data\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt unauthorized data access or processing to ensure access is denied and audit logs record the attempt\n        frame = context.pages[-1]\n        # Input phone number for unauthorized access attempt\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with unauthorized access attempt\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Ao continuar, você concorda com nossos Termos de Serviço e Política de Privacidade').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Criar Conta').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Complete seu cadastro').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Telefone').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Nome Completo *').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=E-mail *').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=CPF *').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Senha *').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Mínimo 8 caracteres').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Confirmar Senha *').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Criar Conta').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Desenvolvido por © Produtora MaxVision 2025 – Todos os direitos reservados.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132041048982//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.667Z",
    "modified": "2025-11-14T14:54:01.206Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "503e027f-2a60-4123-b1e5-06007a230b62",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC011-Progressive Web App (PWA) Offline Support",
    "description": "Check that the PWA features including offline support and service worker registration work as intended.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and click continue to login.\n        frame = context.pages[-1]\n        # Input phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click Entrar to login.\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click Entrar button to submit login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check service worker registration status via browser console or developer tools.\n        frame = context.pages[-1]\n        # Open help menu to check if there is any info or tools related to service worker or PWA status\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close help dialog and proceed to simulate offline mode and reload the app to test offline support.\n        frame = context.pages[-1]\n        # Close help dialog\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode and reload the application to verify offline support.\n        frame = context.pages[-1]\n        # Click switch to light mode button to trigger any service worker or cache update (optional step before offline test)\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/header/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode and reload the application to verify offline support.\n        await page.goto('about:blank', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        await page.goto('http://localhost:8080/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Simulate offline mode and reload the application to verify offline support.\n        await page.goto('about:blank', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        await page.goto('http://localhost:8080/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        frame = context.pages[-1]\n        # Click 'Nova Ação' button to test if adding a new action works offline\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode and attempt to add a new transaction to test offline data queuing.\n        frame = context.pages[-1]\n        # Click 'Nova Transação' to start adding a new transaction\n        elem = frame.locator('xpath=html/body/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input transaction details and save the new transaction while offline.\n        frame = context.pages[-1]\n        # Input transaction value\n        elem = frame.locator('xpath=html/body/div[3]/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('100')\n        \n\n        frame = context.pages[-1]\n        # Open category dropdown\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Service Worker Registration Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The PWA features test plan failed because the service worker registration and offline support did not work as intended.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The PWA features were partially tested. Login and navigation to the dashboard succeeded. Service worker registration and asset caching were not visible on the UI, so could not be confirmed directly. Offline mode was simulated and the new transaction form was opened. Transaction details were input except for the description, but saving the transaction failed due to UI interaction issues. Therefore, offline data queuing and synchronization could not be verified. Overall, the PWA offline support and service worker registration could not be fully confirmed due to these limitations.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132110657008//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.671Z",
    "modified": "2025-11-14T14:55:10.816Z"
  },
  {
    "projectId": "e140a4b7-5b69-4d01-a743-19975b8274ce",
    "testId": "9a29af1b-2a42-4216-92b1-6b7c10e5fa78",
    "userId": "e4b854b8-3041-70d5-59d3-fd5acbcce46c",
    "title": "TC012-Advanced Security: Protected Routes and Data Sanitization",
    "description": "Validate protection of routes, features and input sanitization to prevent unauthorized access and injection attacks.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:8080\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input phone number and click continue to attempt login.\n        frame = context.pages[-1]\n        # Input the phone number for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5511949746110')\n        \n\n        frame = context.pages[-1]\n        # Click the continue button to submit login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click the login button to authenticate.\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('12345678')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/div[2]/main/div/div[2]/div/form/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to access protected routes without authentication by opening a new tab and navigating to a protected route URL directly.\n        await page.goto('http://localhost:8080/contas', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to access the protected route /contas without authentication to verify redirection or access denial.\n        await page.goto('http://localhost:8080/logout', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Return to home page and attempt to access protected features with insufficient permissions.\n        frame = context.pages[-1]\n        # Click 'Return to Home' link to go back to the home page\n        elem = frame.locator('xpath=html/body/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to access a protected feature with insufficient permissions to verify access control.\n        frame = context.pages[-1]\n        # Click on 'Contas' to access account management feature\n        elem = frame.locator('xpath=html/body/div/div[2]/div/aside/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Nova Transação' button to open the form for input sanitization testing.\n        frame = context.pages[-1]\n        # Click 'Nova Transação' button to open new transaction form for input testing\n        elem = frame.locator('xpath=html/body/div/div[2]/div[2]/main/div/div/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a common XSS payload into the 'Descrição' textarea and attempt to save the form to test input sanitization.\n        frame = context.pages[-1]\n        # Input XSS script payload into 'Descrição' textarea for sanitization test\n        elem = frame.locator('xpath=html/body/div[3]/form/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"<script>alert('XSS')</script>\")\n        \n\n        frame = context.pages[-1]\n        # Click 'Salvar' button to submit the form with malicious input\n        elem = frame.locator('xpath=html/body/div[3]/form/div[7]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a common SQL injection string into the 'Descrição' textarea and attempt to save the form to test input sanitization.\n        frame = context.pages[-1]\n        # Input SQL injection payload into 'Descrição' textarea for sanitization test\n        elem = frame.locator('xpath=html/body/div[3]/form/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"' OR '1'='1\")\n        \n\n        frame = context.pages[-1]\n        # Click 'Salvar' button to submit the form with SQL injection input\n        elem = frame.locator('xpath=html/body/div[3]/form/div[7]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a SQL injection string into the 'Valor' field and attempt to save the form to test input sanitization.\n        frame = context.pages[-1]\n        # Input SQL injection payload into 'Valor' field for sanitization test\n        elem = frame.locator('xpath=html/body/div[3]/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill(\"' OR '1'='1\")\n        \n\n        frame = context.pages[-1]\n        # Click 'Salvar' button to submit the form with SQL injection input in 'Valor' field\n        elem = frame.locator('xpath=html/body/div[3]/form/div[7]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill all required fields with valid data and input XSS payload in 'Descrição' field, then submit the form to test input sanitization.\n        frame = context.pages[-1]\n        # Click category dropdown to select a category\n        elem = frame.locator('xpath=html/body/div[3]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Transporte' category to select it, then click 'Salvar' to submit the form.\n        frame = context.pages[-1]\n        # Select 'Transporte' category from dropdown\n        elem = frame.locator('xpath=html/body/div[4]/div/div/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Salvar' button to submit the form and verify input sanitization and protection against injection attacks.\n        frame = context.pages[-1]\n        # Click 'Salvar' button to submit the form with all required fields filled and SQL injection payload\n        elem = frame.locator('xpath=html/body/div[3]/form/div[7]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close the 'Novo Registro' form and conclude the security validation task.\n        frame = context.pages[-1]\n        # Click 'Close' button to close the 'Novo Registro' form\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Você não tem nenhuma conta pendente para pagar.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Gerencie suas contas a pagar e a receber.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=R$ 0,00').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=R$ 1.133.366,66').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Desenvolvido por © Produtora MaxVision 2025 – Todos os direitos reservados.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e4b854b8-3041-70d5-59d3-fd5acbcce46c/1763132168020014//tmp/test_task/result.webm",
    "created": "2025-11-14T14:48:53.676Z",
    "modified": "2025-11-14T14:56:08.146Z"
  }
]
